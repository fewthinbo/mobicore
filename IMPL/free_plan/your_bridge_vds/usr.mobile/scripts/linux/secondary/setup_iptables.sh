#!/bin/bash
# setup_iptables.sh
# Safe minimal iptables setup with dynamic ports from JSON via Python
# Run as root

set -eu

# -------------------------
# Configurable defaults
# -------------------------
SSH_PORT=${SSH_PORT:-22}
ROLLBACK_SEC=${ROLLBACK_SEC:-20}
RULE_FILE="/usr/mobile/iptables.rules"

# -------------------------
# Check and install iptables if needed
# -------------------------
echo "Checking iptables availability..."
if ! command -v iptables >/dev/null 2>&1; then
  echo "Installing iptables..."
  apt-get update
  apt-get install -y iptables iptables-persistent
fi

PY=/usr/bin/python3
PY_SCRIPT_GET_FIELD="/usr/mobile/scripts/secondary/jsonfield-value.py"

# Check python script
if [ ! -f "$PY_SCRIPT_GET_FIELD" ]; then
  echo "Please create $PY_SCRIPT_GET_FIELD and make it executable."
  exit 1
fi
chmod +x "$PY_SCRIPT_GET_FIELD"

# Get dynamic values from JSON
PORT_1=$("$PY" "$PY_SCRIPT_GET_FIELD" --file "/usr/mobile/settings.json" --field mt.this_port)
ALLOW_HOST_TO_PORT_1=$("$PY" "$PY_SCRIPT_GET_FIELD" --file "/usr/mobile/settings.json" --field mt.remote_host)
PUBLIC_PORT=$("$PY" "$PY_SCRIPT_GET_FIELD" --file "/usr/mobile/config.json" --field port_mobile)

echo "PORT_1: $PORT_1, ALLOW_HOST_TO_PORT_1: $ALLOW_HOST_TO_PORT_1, PUBLIC_PORT: $PUBLIC_PORT"

echo "Preparing minimal iptables rules (SSH port: $SSH_PORT)."

# -------------------------
# Define rules in one place
# -------------------------
IPTABLES_RULES=$(cat <<EOF
#!/bin/bash
# $RULE_FILE - generated by script

# Flush existing rules
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X

# Set default policies
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Allow loopback
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# Allow established and related connections
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Allow SSH
iptables -A INPUT -p tcp --dport $SSH_PORT -j ACCEPT

# Allow ICMP (ping)
iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 10/sec -j ACCEPT

# Allow specific host to specific port
iptables -A INPUT -p tcp -s $ALLOW_HOST_TO_PORT_1 --dport $PORT_1 -j ACCEPT

# Allow public port
iptables -A INPUT -p tcp --dport $PUBLIC_PORT -j ACCEPT

# Log dropped packets (optional)
iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables denied: " --log-level 7

# Drop everything else (default policy already set to DROP)
EOF
)

# -------------------------
# Apply rules at runtime
# -------------------------
echo "Adding runtime rules..."
echo "$IPTABLES_RULES" | while read -r line; do
    case "$line" in \#*|'') continue ;; esac
    eval "$line"
done

# -------------------------
# Rollback timer
# -------------------------
echo "You have ${ROLLBACK_SEC} seconds to verify SSH remains connected."
echo "If you confirm, rollback will be cancelled and rules persisted."

_roll_pid=""
( sleep "$ROLLBACK_SEC" && echo "Rollback timer expired: flushing iptables rules!" && iptables -F && iptables -P INPUT ACCEPT && iptables -P FORWARD ACCEPT && exit 0 ) &
_roll_pid=$!

# -------------------------
# Ask for confirmation
# -------------------------
printf "Do you confirm these rules are OK and you remain connected? [y/N]: "
read ANSWER || ANSWER="n"

case "$ANSWER" in
  [Yy]|[Yy][Ee][Ss])
    # Cancel rollback
    if [ -n "$_roll_pid" ]; then
      kill "$_roll_pid" 2>/dev/null || true
      wait "$_roll_pid" 2>/dev/null || true
    fi

    echo "Confirmed. Persisting rules to $RULE_FILE."

    # Write rules to file
    echo "$IPTABLES_RULES" > "$RULE_FILE"
    chmod +x "$RULE_FILE"

    # Save current rules for persistence
    echo "Setting up iptables persistence..."
    
    # Install iptables-persistent if not already installed
    if ! dpkg -l | grep -q iptables-persistent; then
      echo "Installing iptables-persistent..."
      DEBIAN_FRONTEND=noninteractive apt-get install -y iptables-persistent
    fi
    
    if command -v iptables-save >/dev/null 2>&1; then
      mkdir -p /etc/iptables
      iptables-save > /etc/iptables/rules.v4
      echo "Rules saved to /etc/iptables/rules.v4"
      
      # Also save using netfilter-persistent if available
      if command -v netfilter-persistent >/dev/null 2>&1; then
        netfilter-persistent save
        echo "Rules also saved via netfilter-persistent"
      fi
    fi

    # Install and configure fail2ban for SSH protection
    echo "Installing fail2ban for SSH brute-force protection..."
    if ! dpkg -l | grep -q fail2ban; then
      apt-get update
      apt-get install -y fail2ban
    fi
    
    # Configure fail2ban if installed
    if command -v fail2ban-server >/dev/null 2>&1; then
      # Create basic jail.local config
      cat > /etc/fail2ban/jail.local <<EOF
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 5

[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 3600
EOF
      
      # Enable and start fail2ban
      systemctl enable fail2ban
      systemctl restart fail2ban
      echo "Fail2ban configured and started for SSH protection."
    fi

    echo "Rules persisted and will be restored on boot."
    ;;

  *)
    echo "No confirmation received. Performing immediate rollback."
    if [ -n "$_roll_pid" ]; then
      kill "$_roll_pid" 2>/dev/null || true
      wait "$_roll_pid" 2>/dev/null || true
    fi
    iptables -F
    iptables -P INPUT ACCEPT
    iptables -P FORWARD ACCEPT
    echo "Rules flushed. You should still be connected."
    exit 1
    ;;
esac

exit 0