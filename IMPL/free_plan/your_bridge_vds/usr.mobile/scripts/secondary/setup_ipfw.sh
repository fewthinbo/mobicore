#!/bin/sh
# enable_ipfw_dynamic.sh
# Safe minimal ipfw setup with dynamic ports from JSON via Python
# Run as root

set -eu

# -------------------------
# Configurable defaults
# -------------------------
SSH_PORT=${SSH_PORT:-22}
ROLLBACK_SEC=${ROLLBACK_SEC:-20}
RULE_FILE="/etc/ipfw.rules"

PY=/usr/local/bin/python3
PY_SCRIPT_GET_FIELD="/usr/mobile/scripts/secondary/jsonfield-value.py"

# Check python script
if [ ! -f "$PY_SCRIPT_GET_FIELD" ]; then
  echo "Please create $PY_SCRIPT_GET_FIELD and make it executable."
  exit 1
fi
chmod +x "$PY_SCRIPT_GET_FIELD"

# Get dynamic values from JSON
PORT_1=$("$PY" "$PY_SCRIPT_GET_FIELD" --file "/usr/mobile/settings.json" --field mt.this_port)
ALLOW_HOST_TO_PORT_1=$("$PY" "$PY_SCRIPT_GET_FIELD" --file "/usr/mobile/settings.json" --field mt.remote_host)
PUBLIC_PORT=$("$PY" "$PY_SCRIPT_GET_FIELD" --file "/usr/mobile/config.json" --field port_mobile)

echo "Preparing minimal ipfw rules (SSH port: $SSH_PORT)."

# -------------------------
# Define rules in one place
# -------------------------
IPFW_RULES=$(cat <<EOF
#!/bin/sh
# /etc/ipfw.rules - generated by enable_ipfw_dynamic.sh
ipfw -q flush
ipfw -q add 1000 allow all from any to 127.0.0.1
ipfw -q add 1010 allow all from 127.0.0.1 to any
ipfw -q add 1020 allow tcp from any to me $SSH_PORT in setup keep-state
ipfw -q add 1030 allow tcp from me to any established
ipfw -q add 1040 allow ip from me to any out keep-state
ipfw -q add 1050 allow icmp from any to any
ipfw -q add 1060 allow tcp from $ALLOW_HOST_TO_PORT_1 to me $PORT_1
ipfw -q add 1070 allow tcp from any to me $PUBLIC_PORT
ipfw -q add 65534 deny ip from any to any
EOF
)

# -------------------------
# Apply rules at runtime
# -------------------------
echo "Adding runtime rules..."
echo "$IPFW_RULES" | while read -r line; do
    case "$line" in \#*|'') continue ;; esac
    eval "$line"
done

echo "Runtime rules added. Not yet persisted to boot."

# -------------------------
# Start ipfw service if needed
# -------------------------
echo "Starting ipfw service..."
service ipfw onestart || service ipfw start || true

# -------------------------
# Rollback timer
# -------------------------
echo "You have ${ROLLBACK_SEC} seconds to verify SSH remains connected."
echo "If you confirm, rollback will be cancelled and rules persisted."

_roll_pid=""
( sleep "$ROLLBACK_SEC" && echo "Rollback timer expired: flushing ipfw rules!" && ipfw -q -f flush && exit 0 ) &
_roll_pid=$!

# -------------------------
# Ask for confirmation
# -------------------------
printf "Do you confirm these rules are OK and you remain connected? [y/N]: "
read ANSWER || ANSWER="n"

case "$ANSWER" in
  [Yy]|[Yy][Ee][Ss])
    # Cancel rollback
    if [ -n "$_roll_pid" ]; then
      kill "$_roll_pid" 2>/dev/null || true
      wait "$_roll_pid" 2>/dev/null || true
    fi

    echo "Confirmed. Persisting rules to $RULE_FILE."

    # Write rules to file
    echo "$IPFW_RULES" > "$RULE_FILE"
    chmod +x "$RULE_FILE"

    # rc.conf setup
    if ! grep -q '^firewall_enable=' /etc/rc.conf 2>/dev/null; then
      echo 'firewall_enable="YES"' >> /etc/rc.conf
    else
      sed -i '' 's/^firewall_enable=.*$/firewall_enable="YES"/' /etc/rc.conf
    fi

    if ! grep -q '^firewall_script=' /etc/rc.conf 2>/dev/null; then
      echo "firewall_script=\"$RULE_FILE\"" >> /etc/rc.conf
    else
      sed -i '' "s|^firewall_script=.*$|firewall_script=\"$RULE_FILE\"|" /etc/rc.conf
    fi

    # Restart service to apply persistent rules
    service ipfw restart || service ipfw onestart || true
    echo "Rules persisted. ipfw active and will persist on boot."
    ;;

  *)
    echo "No confirmation received. Performing immediate rollback."
    if [ -n "$_roll_pid" ]; then
      kill "$_roll_pid" 2>/dev/null || true
      wait "$_roll_pid" 2>/dev/null || true
    fi
    ipfw -q -f flush
    echo "Rules flushed. You should still be connected."
    exit 1
    ;;
esac

exit 0
