#!/bin/sh
# enable_ipfw_dynamic.sh
# Safe minimal ipfw setup with dynamic ports from JSON via Python
# Run as root

set -eu

# -------------------------
# Configurable defaults
# -------------------------
SSH_PORT=${SSH_PORT:-22}
ROLLBACK_SEC=${ROLLBACK_SEC:-20}
RULE_FILE="/usr/mobile/ipfw.rules"

# -------------------------
# Check and load ipfw kernel module
# -------------------------
echo "Checking ipfw kernel module..."
if ! kldstat | grep -q ipfw; then
  echo "Loading ipfw kernel module..."
  echo "WARNING: This will temporarily block all traffic!"
  echo "Adding emergency SSH rule immediately after loading..."
  
  kldload ipfw || {
    echo "Failed to load ipfw module. Make sure you're running as root."
    exit 1
  }
  
  # Immediately add emergency SSH rule to prevent lockout
  echo "Adding emergency SSH access rule..."
  ipfw -q add 100 allow tcp from any to me $SSH_PORT
  ipfw -q add 110 allow tcp from me to any established
  ipfw -q add 120 allow all from any to 127.0.0.1
  ipfw -q add 130 allow all from 127.0.0.1 to any
  echo "Emergency SSH rule added. Connection should be restored."
fi

PY=/usr/local/bin/python3
PY_SCRIPT_GET_FIELD="/usr/mobile/scripts/secondary/jsonfield-value.py"

# Check python script
if [ ! -f "$PY_SCRIPT_GET_FIELD" ]; then
  echo "Please create $PY_SCRIPT_GET_FIELD and make it executable."
  exit 1
fi
chmod +x "$PY_SCRIPT_GET_FIELD"

# Get dynamic values from JSON
PORT_1=$("$PY" "$PY_SCRIPT_GET_FIELD" --file "/usr/mobile/settings.json" --field mt.this_port)
ALLOW_HOST_TO_PORT_1=$("$PY" "$PY_SCRIPT_GET_FIELD" --file "/usr/mobile/settings.json" --field mt.remote_host)
PUBLIC_PORT=$("$PY" "$PY_SCRIPT_GET_FIELD" --file "/usr/mobile/config.json" --field port_mobile)

echo "PORT_1: $PORT_1, ALLOW_HOST_TO_PORT_1: $ALLOW_HOST_TO_PORT_1, PUBLIC_PORT: $PUBLIC_PORT"

echo "Preparing minimal ipfw rules (SSH port: $SSH_PORT)."

# -------------------------
# Define rules in one place
# -------------------------
IPFW_RULES=$(cat <<EOF
#!/bin/sh
# $RULE_FILE - generated by script
ipfw -q -f flush
ipfw add 1000 allow all from any to 127.0.0.1
ipfw add 1010 allow all from 127.0.0.1 to any
ipfw add 1020 allow tcp from any to me $SSH_PORT
ipfw add 1030 allow tcp from me to any established
ipfw add 1040 allow ip from me to any out keep-state :default
ipfw add 1050 allow icmp from any to any icmptypes 0,8 icmptypes 8,0 limit src-addr 10 :default
ipfw add 1060 allow tcp from $ALLOW_HOST_TO_PORT_1 to me $PORT_1
ipfw add 1070 allow tcp from any to me $PUBLIC_PORT
ipfw add 65534 deny ip from any to any
EOF
)

# -------------------------
# Apply rules at runtime
# -------------------------
echo "Adding runtime rules..."
echo "$IPFW_RULES" | while read -r line; do
    case "$line" in \#*|'') continue ;; esac
    eval "$line"
done

# -------------------------
# Rollback timer
# -------------------------
echo "You have ${ROLLBACK_SEC} seconds to verify SSH remains connected."
echo "If you confirm, rollback will be cancelled and rules persisted."

_roll_pid=""
( sleep "$ROLLBACK_SEC" && echo "Rollback timer expired: flushing ipfw rules!" && ipfw -q -f flush && exit 0 ) &
_roll_pid=$!

# -------------------------
# Ask for confirmation
# -------------------------
printf "Do you confirm these rules are OK and you remain connected? [y/N]: "
read ANSWER || ANSWER="n"

case "$ANSWER" in
  [Yy]|[Yy][Ee][Ss])
    # Cancel rollback
    if [ -n "$_roll_pid" ]; then
      kill "$_roll_pid" 2>/dev/null || true
      wait "$_roll_pid" 2>/dev/null || true
    fi

    echo "Confirmed. Persisting rules to $RULE_FILE."

    # Write rules to file
    echo "$IPFW_RULES" > "$RULE_FILE"
    chmod +x "$RULE_FILE"

	# Enable ipfw in rc.conf for boot persistence
	if ! grep -q '^firewall_enable=' /etc/rc.conf 2>/dev/null; then
		echo 'firewall_enable="YES"' >> /etc/rc.conf
		echo "Added firewall_enable to rc.conf"
	fi

    # rc.conf setup for firewall script
    if ! grep -q '^firewall_script=' /etc/rc.conf 2>/dev/null; then
      echo "firewall_script=\"$RULE_FILE\"" >> /etc/rc.conf
    else
      sed "s|^firewall_script=.*$|firewall_script=\"$RULE_FILE\"|" /etc/rc.conf > /etc/rc.conf.tmp && mv /etc/rc.conf.tmp /etc/rc.conf
    fi

    # Note: We don't restart the service as it would override our custom rules
    echo "Rules persisted to $RULE_FILE and will load on boot."

	echo "Rules are loading."
	if sh "$RULE_FILE"; then
		echo "[$RULE_FILE] loaded successfully."
	fi

    # Install and configure fail2ban for SSH protection
    echo "Installing fail2ban for SSH brute-force protection..."
    if ! pkg info fail2ban >/dev/null 2>&1; then
      pkg install -y py311-fail2ban || pkg install -y fail2ban || {
        echo "Warning: Could not install fail2ban. You may install it manually later."
      }
    fi
    
    # Configure fail2ban if installed
    if command -v fail2ban-server >/dev/null 2>&1; then
      # Create basic jail.local config
      cat > /usr/local/etc/fail2ban/jail.local <<EOF
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 5

[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 3600
EOF
      
      # Enable and start fail2ban
      if ! grep -q '^fail2ban_enable=' /etc/rc.conf 2>/dev/null; then
        echo 'fail2ban_enable="YES"' >> /etc/rc.conf
      fi
      
      service fail2ban start 2>/dev/null || service fail2ban onestart 2>/dev/null || true
      echo "Fail2ban configured and started for SSH protection."
    fi
    ;;

  *)
    echo "No confirmation received. Performing immediate rollback."
    if [ -n "$_roll_pid" ]; then
      kill "$_roll_pid" 2>/dev/null || true
      wait "$_roll_pid" 2>/dev/null || true
    fi
    ipfw -q -f flush
    echo "Rules flushed. You should still be connected."
    exit 1
    ;;
esac

exit 0
